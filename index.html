<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Time Keeper</title>
    <!-- Google Fonts: Poppins and Roboto Slab for a modern look -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&family=Roboto+Slab:wght@100..900&display=swap"
      rel="stylesheet"
    />
    <style>
      /* Universal box-sizing and font-family */
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: "Poppins", Tahoma, Geneva, Verdana, sans-serif;
      }

      /* Body styling for full-page background and centering */
      body {
        font-family: "Poppins", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(
          135deg,
          #a8e6cf 0%,
          /* Light green */ #dcedc1 50%,
          /* Lighter green */ #ffd3a5 100% /* Light orange */
        );
        min-height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 20px;
      }

      /* Main container for the timer application */
      .container {
        background: rgba(255, 255, 255, 0.9); /* Semi-transparent white */
        backdrop-filter: blur(10px); /* Frosted glass effect */
        border-radius: 20px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        padding: 40px;
        text-align: center;
        max-width: 500px;
        width: 100%;
        border: 1px solid rgba(255, 255, 255, 0.3);
      }

      /* Heading styling */
      h1 {
        color: #5e5e5e;
        margin-bottom: 30px;
        font-size: 2.5em;
        font-weight: bold;
      }

      /* Timer display styling */
      .timer-display {
        font-size: 4em;
        font-weight: bold;
        color: #5a6c7d; /* Dark bluish-gray */
        margin: 10px 0;
        font-family: "Poppins", monospace; /* Monospace for consistent digits */
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
      }

      /* Alert state for timer display (when time is up) */
      .timer-display.alert {
        color: #f4a6a6; /* Light red */
        animation: pulse 1s infinite; /* Pulsing animation */
      }

      /* Pulsing keyframe animation for alert state */
      @keyframes pulse {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
        100% {
          transform: scale(1);
        }
      }

      /* Input fields container */
      .time-inputs {
        display: flex;
        justify-content: center;
        gap: 20px;
        margin: 30px 0;
        flex-wrap: wrap;
        text-align: center;
      }

      /* Sound selector section */
      .sound-selector {
        margin: 20px 0;
        text-align: center;
      }

      .sound-selector label {
        display: block;
        font-weight: 600;
        color: #555;
        margin-bottom: 10px;
      }

      .sound-selector select {
        padding: 0px 10px;
        font-size: 1em;
        border: 2px solid #ddd;
        border-radius: 10px;
        background: white;
        outline: none;
        transition: all 0.3s ease;
        margin-right: 10px;
        min-width: 160px;
        height: 40px;
      }

      .sound-selector select:focus {
        border-color: #667eea;
        box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
      }

      /* Styling for the custom sound upload button */
      #uploadBtn {
        padding: 8px 15px;
        font-size: 0.9em;
        background: linear-gradient(
          45deg,
          #9c27b0,
          #7b1fa2
        ); /* Purple gradient */
        color: white;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        transition: all 0.3s ease;
        height: 40px;
      }

      #uploadBtn:hover {
        transform: translateY(-1px);
        box-shadow: 0 3px 10px rgba(156, 39, 176, 0.4);
      }

      /* Individual time input group (minutes, seconds) */
      .time-input-group {
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      .time-input-group label {
        font-weight: 600;
        color: #555;
        margin-bottom: 5px;
        font-size: 0.9em;
      }

      .time-input-group input {
        width: 80px;
        height: 40px;
        font-size: 1.2em;
        text-align: center;
        border: 2px solid #ddd;
        border-radius: 10px;
        outline: none;
        transition: all 0.3s ease;
      }

      .time-input-group input:focus {
        border-color: #a8e6cf;
        box-shadow: 0 0 0 3px rgba(168, 230, 207, 0.3);
      }

      /* Container for all control buttons */
      .controls {
        display: flex;
        justify-content: center;
        gap: 15px;
        margin: 30px 0;
        flex-wrap: wrap;
      }

      /* Styling for preset time buttons */
      .preset-buttons {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-bottom: 20px;
        flex-wrap: wrap;
      }

      .preset-buttons button {
        background: linear-gradient(
          45deg,
          #f0f0f0,
          #e0e0e0
        ); /* Light gray gradient */
        color: #444;
        border: 1px solid rgba(0, 0, 0, 0.1);
        padding: 8px 15px;
        font-size: 0.9em;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
        min-width: unset; /* Override general button min-width */
        height: unset; /* Override general button height */
      }

      .preset-buttons button:hover {
        background: linear-gradient(45deg, #e0e0e0, #d0d0d0);
        transform: translateY(-1px);
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      }

      /* Base styling for all buttons */
      button {
        padding: 0px; /* Padding set by min-width/height */
        font-size: 1.1em;
        font-weight: 600;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        transition: all 0.3s ease;
        min-width: 150px;
        height: 40px;
      }

      /* Specific styling for Start button */
      .start-btn {
        background: linear-gradient(
          45deg,
          #b8e6b8,
          #a3d977
        ); /* Green gradient */
        color: #2d5a2d;
        border: 1px solid rgba(163, 217, 119, 0.3);
      }

      .start-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(184, 230, 184, 0.4);
        background: linear-gradient(45deg, #a3d977, #8fd14f);
      }

      /* Specific styling for Stop/Pause button */
      .stop-btn {
        background: linear-gradient(45deg, #f4a6a6, #e89090); /* Red gradient */
        color: #5d2d2d;
        border: 1px solid rgba(232, 144, 144, 0.3);
      }

      .stop-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(244, 166, 166, 0.4);
        background: linear-gradient(45deg, #e89090, #dc7a7a);
      }

      /* Specific styling for Reset button */
      .reset-btn {
        background: linear-gradient(
          45deg,
          #a6c8f4,
          #90b3e8
        ); /* Blue gradient */
        color: #2d4a5d;
        border: 1px solid rgba(144, 179, 232, 0.3);
      }

      .reset-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(166, 200, 244, 0.4);
        background: linear-gradient(45deg, #90b3e8, #7a9fdc);
      }

      /* Specific styling for Test button */
      .test-btn {
        background: linear-gradient(
          45deg,
          #f4d4a6,
          #e8c490
        ); /* Orange gradient */
        color: #5d4a2d;
        border: 1px solid rgba(232, 196, 144, 0.3);
      }

      .test-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(244, 212, 166, 0.4);
        background: linear-gradient(45deg, #e8c490, #dcb47a);
      }

      /* Progress bar styling */
      .progress-bar {
        width: 100%;
        height: 8px;
        background: #e0e0e0;
        border-radius: 4px;
        margin: 20px 0;
        overflow: hidden;
      }

      /* Progress fill styling */
      .progress-fill {
        height: 100%;
        background: linear-gradient(45deg, #a8e6cf, #dcedc1);
        transition: width 0.1s ease; /* Smooth transition for width changes */
        border-radius: 4px;
      }

      /* Modal for alert messages */
      .alert-modal {
        display: none; /* Hidden by default, shown with JavaScript */
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8); /* Dark overlay */
        z-index: 1000;
        justify-content: center;
        align-items: center;
      }

      /* Content inside the alert modal */
      .alert-content {
        background: white;
        padding: 40px;
        border-radius: 20px;
        text-align: center;
        max-width: 400px;
        width: 90%;
        animation: alertPop 0.5s ease-out; /* Pop-up animation */
      }

      /* Keyframe animation for alert modal pop-up */
      @keyframes alertPop {
        0% {
          transform: scale(0.5);
          opacity: 0;
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }

      .alert-content h2 {
        color: #e74c3c; /* Red color for alert heading */
        margin-bottom: 20px;
        font-size: 2em;
      }

      .alert-content p {
        font-size: 1.2em;
        color: #333;
        margin-bottom: 20px;
      }

      /* Close button for the alert modal */
      .close-alert {
        background: linear-gradient(45deg, #e74c3c, #c0392b); /* Red gradient */
        color: white;
        padding: 10px 20px;
        border: none;
        border-radius: 15px;
        cursor: pointer;
        font-size: 1.1em;
      }

      /* Responsive adjustments for smaller screens */
      @media (max-width: 600px) {
        .container {
          padding: 20px;
        }

        .timer-display {
          font-size: 2.5em;
        }

        .time-inputs {
          gap: 10px;
        }

        .time-input-group input {
          width: 60px;
          height: 40px;
          font-size: 1.2em;
        }

        .controls {
          gap: 10px;
        }

        button {
          padding: 10px 18px;
          font-size: 1em;
          min-width: 80px;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Time Keeper</h1>

      <!-- Main timer display (minutes:seconds) -->
      <div class="timer-display" id="timerDisplay">00:00</div>

      <!-- Progress bar to visualize timer progress -->
      <div class="progress-bar">
        <div class="progress-fill" id="progressFill"></div>
      </div>

      <!-- Input fields for minutes and seconds -->
      <div class="time-inputs">
        <div class="time-input-group">
          <label for="minutes">Minutes</label>
          <input type="number" id="minutes" min="0" max="59" value="15" />
        </div>
        <div class="time-input-group">
          <label for="seconds">Seconds</label>
          <input type="number" id="seconds" min="0" max="59" value="00" />
        </div>
      </div>

      <!-- New: Preset time buttons -->
      <div class="preset-buttons">
        <button id="preset5Min">5 Minutes</button>
        <button id="preset10Min">10 Minutes</button>
        <button id="preset15Min">15 Minutes</button>
      </div>

      <!-- Alarm sound selection and custom upload -->
      <div class="sound-selector">
        <label for="soundSelect">Alarm Sound:</label>
        <select id="soundSelect">
          <option value="beep">Default Beep</option>
          <option value="bell">Bell</option>
          <option value="horn">Air Horn</option>
          <option value="custom">Custom Sound</option>
        </select>
        <input
          type="file"
          id="customSound"
          accept="audio/*"
          style="display: none"
        />
        <button id="uploadBtn" style="display: none">Upload Sound</button>
      </div>

      <!-- Control buttons for the timer -->
      <div class="controls">
        <button class="start-btn" id="startBtn">Start</button>
        <button class="stop-btn" id="stopBtn">Stop</button>
        <button class="reset-btn" id="resetBtn">Reset</button>
        <button class="test-btn" id="testBtn">Test</button>
      </div>
    </div>

    <!-- Custom alert modal (instead of browser's alert()) -->
    <div class="alert-modal" id="alertModal">
      <div class="alert-content">
        <h2>⏰ Time's Up!</h2>
        <p>Your timer has finished!</p>
        <button class="close-alert" id="closeAlert">OK</button>
      </div>
    </div>

    <script>
      /**
       * The Timer class encapsulates all the logic and state for the countdown timer.
       */
      class Timer {
        constructor() {
          this.totalSeconds = 0; // The initial total time set for the timer
          this.remainingSeconds = 0; // The current remaining time
          this.isRunning = false; // Flag to check if the timer is currently running
          this.intervalId = null; // Stores the ID returned by setInterval for clearing
          this.audioContext = null; // Web Audio API AudioContext for sound playback
          this.customAudioBuffer = null; // Stores decoded custom audio file
          this.selectedSound = "beep"; // Currently selected alarm sound
          this.startTime = null; // Timestamp when the timer was started or resumed
          this.pausedTime = 0; // Accumulated paused time to maintain accuracy
          this.wakeLock = null; // Stores the wake lock object for screen control

          // Initialize DOM elements
          this.initializeElements();
          // Bind event listeners to controls
          this.bindEvents();
          // Update the display initially based on input values
          this.updateDisplay();
          // Set up handling for page visibility changes
          this.setupVisibilityHandling();
        }

        /**
         * Fetches and assigns references to all necessary DOM elements.
         */
        initializeElements() {
          this.timerDisplay = document.getElementById("timerDisplay");
          this.progressFill = document.getElementById("progressFill");
          this.minutesInput = document.getElementById("minutes");
          this.secondsInput = document.getElementById("seconds");
          this.startBtn = document.getElementById("startBtn");
          this.stopBtn = document.getElementById("stopBtn");
          this.resetBtn = document.getElementById("resetBtn");
          this.testBtn = document.getElementById("testBtn");
          this.alertModal = document.getElementById("alertModal");
          this.closeAlert = document.getElementById("closeAlert");
          this.soundSelect = document.getElementById("soundSelect");
          this.customSound = document.getElementById("customSound");
          this.uploadBtn = document.getElementById("uploadBtn");

          // References for new preset buttons
          this.preset5MinBtn = document.getElementById("preset5Min");
          this.preset10MinBtn = document.getElementById("preset10Min");
          this.preset15MinBtn = document.getElementById("preset15Min");
        }

        /**
         * Attaches event listeners to all interactive elements.
         */
        bindEvents() {
          this.startBtn.addEventListener("click", () => this.toggle());
          this.stopBtn.addEventListener("click", () => this.stop());
          this.resetBtn.addEventListener("click", () => this.reset());
          this.testBtn.addEventListener("click", () => this.testAlert());
          this.closeAlert.addEventListener("click", () =>
            this.closeAlertModal()
          );

          // Event listeners for sound selection
          this.soundSelect.addEventListener("change", () =>
            this.handleSoundChange()
          );
          this.customSound.addEventListener("change", () =>
            this.handleCustomSound()
          );
          this.uploadBtn.addEventListener("click", () =>
            this.customSound.click()
          );

          // Update timer when input fields change (only if not running)
          [this.minutesInput, this.secondsInput].forEach((input) => {
            input.addEventListener("change", () => {
              if (!this.isRunning) {
                this.setTime();
              }
            });
          });

          // Event listeners for new preset buttons
          this.preset5MinBtn.addEventListener("click", () => this.setPreset(5));
          this.preset10MinBtn.addEventListener("click", () =>
            this.setPreset(10)
          );
          this.preset15MinBtn.addEventListener("click", () =>
            this.setPreset(15)
          );
        }

        /**
         * Sets up event listeners for page visibility and window focus/blur.
         * This helps synchronize the timer when the page is brought back into focus,
         * accounting for potential browser throttling in background tabs.
         */
        setupVisibilityHandling() {
          document.addEventListener("visibilitychange", () => {
            if (this.isRunning) {
              this.syncTimer();
            }
          });

          window.addEventListener("focus", () => {
            if (this.isRunning) {
              this.syncTimer();
            }
          });

          window.addEventListener("blur", () => {
            if (this.isRunning) {
              this.syncTimer();
            }
          });
        }

        /**
         * Requests a screen wake lock to prevent the screen from turning off.
         * This is useful to ensure the alarm plays even if the user isn't actively interacting.
         * Requires user gesture to activate.
         */
        async requestWakeLock() {
          // Check if Wake Lock API is supported by the browser
          if ("wakeLock" in navigator) {
            try {
              // Request a 'screen' wake lock
              this.wakeLock = await navigator.wakeLock.request("screen");
              console.log("Screen Wake Lock acquired!");
              // Add a listener for when the wake lock is released by the system
              this.wakeLock.addEventListener("release", () => {
                console.log("Screen Wake Lock released!");
                this.wakeLock = null; // Clear the reference
              });
            } catch (err) {
              // Handle errors (e.g., user denied permission, system limitations)
              if (err.name === "NotAllowedError") {
                console.error(
                  `Wake Lock Error: ${err.name} - ${err.message}. This usually means the page needs to be served over HTTPS and/or user permission is required.`
                );
              } else {
                console.error(`Wake Lock Error: ${err.name}, ${err.message}`);
              }
            }
          } else {
            console.warn("Wake Lock API not supported in this browser.");
          }
        }

        /**
         * Releases any active screen wake lock.
         */
        releaseWakeLock() {
          if (this.wakeLock) {
            this.wakeLock.release();
            this.wakeLock = null; // Clear the reference
            console.log("Screen Wake Lock released programmatically.");
          }
        }

        /**
         * Synchronizes the timer's remaining time based on the actual elapsed time.
         * This accounts for discrepancies caused by browser throttling or tab changes.
         */
        syncTimer() {
          if (!this.isRunning || !this.startTime) return;

          const now = Date.now();
          // Calculate time elapsed since the timer started/resumed
          const elapsed = Math.floor((now - this.startTime) / 1000);
          // Calculate new remaining seconds considering total time and paused time
          const newRemainingSeconds =
            this.totalSeconds - elapsed - this.pausedTime;

          if (newRemainingSeconds <= 0) {
            // If time is up, complete the timer
            this.remainingSeconds = 0;
            this.complete();
          } else {
            // Otherwise, update remaining time and display
            this.remainingSeconds = newRemainingSeconds;
            this.updateDisplay();
            this.updateProgress();
          }
        }

        /**
         * Sets the total and remaining time for the timer based on input fields.
         */
        setTime() {
          const minutes = parseInt(this.minutesInput.value) || 0;
          const seconds = parseInt(this.secondsInput.value) || 0;

          // Calculate total seconds (minutes * 60 + seconds)
          this.totalSeconds = minutes * 60 + seconds;
          this.remainingSeconds = this.totalSeconds;
          this.pausedTime = 0; // Reset paused time when setting new total

          this.updateDisplay();
          this.updateProgress();
        }

        /**
         * Sets the timer to a predefined number of minutes.
         * @param {number} minutes The number of minutes for the preset.
         */
        setPreset(minutes) {
          this.minutesInput.value = minutes;
          this.secondsInput.value = 0;
          this.setTime(); // Update the timer's internal state
          this.reset(); // Reset the timer to apply the new preset and refresh display
        }

        /**
         * Toggles the timer between start/pause states.
         */
        toggle() {
          if (this.isRunning) {
            this.pause();
          } else {
            this.start();
          }
        }

        /**
         * Starts the countdown timer.
         */
        start() {
          // If remaining time is 0, set time from inputs before starting
          if (this.remainingSeconds <= 0) {
            this.setTime();
          }

          // Only start if there's time to count down
          if (this.remainingSeconds > 0) {
            this.isRunning = true;
            this.startTime = Date.now(); // Record start time for accurate tracking
            this.startBtn.textContent = "Pause";
            this.startBtn.className = "stop-btn"; // Change button style to indicate pause

            this.requestWakeLock(); // Request screen wake lock

            // Set up interval to update timer frequently (100ms for smoother progress bar)
            this.intervalId = setInterval(() => {
              this.syncTimer(); // Use syncTimer to handle potential throttling
            }, 100);
          }
        }

        /**
         * Pauses the countdown timer.
         */
        pause() {
          this.isRunning = false;
          this.startBtn.textContent = "Start";
          this.startBtn.className = "start-btn"; // Change button style back to start

          this.releaseWakeLock(); // Release screen wake lock

          // Clear the interval to stop the timer
          if (this.intervalId) {
            clearInterval(this.intervalId);
            this.intervalId = null;
          }

          // Accumulate paused time if the timer was running before pause
          if (this.startTime) {
            const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
            this.pausedTime += elapsed;
          }
        }

        /**
         * Stops the timer and resets it to its initial set time.
         */
        stop() {
          this.pause(); // Pause any active timer
          this.remainingSeconds = this.totalSeconds; // Reset to initial total
          this.pausedTime = 0; // Clear paused time
          this.startTime = null; // Clear start timestamp
          this.updateDisplay(); // Update display
          this.updateProgress(); // Reset progress bar
        }

        /**
         * Resets the timer to its initial configured state (from inputs).
         */
        reset() {
          this.pause(); // Pause any active timer
          this.pausedTime = 0; // Clear paused time
          this.startTime = null; // Clear start timestamp
          this.setTime(); // Re-read inputs and set timer
          this.timerDisplay.classList.remove("alert"); // Remove alert styling
        }

        /**
         * Handles the completion of the timer (when remainingSeconds reaches 0).
         */
        complete() {
          this.pause(); // Pause the timer
          this.remainingSeconds = 0; // Ensure display shows 00:00
          this.updateDisplay();
          this.updateProgress();
          this.timerDisplay.classList.add("alert"); // Add alert styling
          this.playAlert(); // Play selected alarm sound
          this.showAlert(); // Show custom alert modal
          this.releaseWakeLock(); // Release screen wake lock
        }

        /**
         * Updates the timer display with formatted minutes and seconds.
         */
        updateDisplay() {
          const minutes = Math.floor(this.remainingSeconds / 60);
          const seconds = this.remainingSeconds % 60;

          // Format as MM:SS (e.g., 05:30)
          this.timerDisplay.textContent = `${minutes
            .toString()
            .padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;
        }

        /**
         * Updates the width of the progress bar based on elapsed time.
         */
        updateProgress() {
          if (this.totalSeconds > 0) {
            const progress =
              ((this.totalSeconds - this.remainingSeconds) /
                this.totalSeconds) *
              100;
            this.progressFill.style.width = `${progress}%`;
          } else {
            this.progressFill.style.width = "0%"; // No progress if total time is 0
          }
        }

        /**
         * Plays the currently selected alarm sound.
         */
        async playAlert() {
          // Attempt to resume audio context if it's suspended due to autoplay policy
          if (this.audioContext && this.audioContext.state === "suspended") {
            await this.audioContext.resume();
          }

          switch (this.selectedSound) {
            case "custom":
              if (this.customAudioBuffer) {
                await this.playCustomSound();
              } else {
                this.playBeepSound(); // Fallback to beep if custom sound fails or not loaded
              }
              break;
            case "bell":
              await this.playBellSound();
              break;
            case "horn":
              await this.playHornSound();
              break;
            default:
              this.playBeepSound(); // Default beep sound
          }
        }

        /**
         * Plays the loaded custom audio buffer.
         */
        async playCustomSound() {
          try {
            // Create AudioContext on first play if not already created (user gesture required)
            if (!this.audioContext) {
              this.audioContext = new (window.AudioContext ||
                window.webkitAudioContext)();
            }

            // Ensure context is running, especially if created outside a direct user gesture
            if (this.audioContext.state === "suspended") {
              await this.audioContext.resume();
            }

            if (!this.customAudioBuffer) {
              console.warn(
                "No custom audio buffer loaded. Playing default beep."
              );
              this.playBeepSound(); // Fallback if custom sound not ready
              return;
            }

            const source = this.audioContext.createBufferSource();
            const gainNode = this.audioContext.createGain();

            source.buffer = this.customAudioBuffer;
            source.connect(gainNode);
            gainNode.connect(this.audioContext.destination);

            gainNode.gain.setValueAtTime(0.7, this.audioContext.currentTime); // Set volume
            source.start(); // Play the sound
          } catch (error) {
            console.error("Error playing custom sound:", error);
            this.playBeepSound(); // Fallback on error
          }
        }

        /**
         * Generates and plays a bell-like sound using Web Audio API.
         */
        async playBellSound() {
          try {
            if (!this.audioContext) {
              this.audioContext = new (window.AudioContext ||
                window.webkitAudioContext)();
            }
            if (this.audioContext.state === "suspended") {
              await this.audioContext.resume();
            }

            // Create multiple oscillators for a richer, bell-like harmonic sound
            for (let i = 0; i < 3; i++) {
              setTimeout(() => {
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                // Different frequencies for harmonic effect
                oscillator.frequency.setValueAtTime(
                  523 + i * 100, // Base frequency + harmonics
                  this.audioContext.currentTime
                );
                gainNode.gain.setValueAtTime(
                  0.2 / (i + 1), // Decrease gain for higher harmonics
                  this.audioContext.currentTime
                );
                // Exponential decay for the bell sound
                gainNode.gain.exponentialRampToValueAtTime(
                  0.01,
                  this.audioContext.currentTime + 2
                );

                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + 2); // Stop after 2 seconds
              }, i * 200); // Stagger the starts of each harmonic
            }
          } catch (error) {
            console.error("Error playing bell sound:", error);
            this.playBeepSound(); // Fallback on error
          }
        }

        /**
         * Generates and plays an air horn-like sound using Web Audio API.
         */
        async playHornSound() {
          try {
            if (!this.audioContext) {
              this.audioContext = new (window.AudioContext ||
                window.webkitAudioContext)();
            }
            if (this.audioContext.state === "suspended") {
              await this.audioContext.resume();
            }

            const oscillator = this.audioContext.createOscillator();
            const gainNode = this.audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(this.audioContext.destination);

            // Frequency sweep for air horn effect
            oscillator.frequency.setValueAtTime(
              200, // Starting frequency
              this.audioContext.currentTime
            );
            oscillator.frequency.linearRampToValueAtTime(
              400, // Ending frequency
              this.audioContext.currentTime + 0.1
            );
            oscillator.frequency.setValueAtTime(
              400, // Hold frequency
              this.audioContext.currentTime + 1
            );

            gainNode.gain.setValueAtTime(0.5, this.audioContext.currentTime); // Set initial volume
            // Exponential decay for the horn sound
            gainNode.gain.exponentialRampToValueAtTime(
              0.01,
              this.audioContext.currentTime + 1
            );

            oscillator.start();
            oscillator.stop(this.audioContext.currentTime + 1); // Stop after 1 second
          } catch (error) {
            console.error("Error playing horn sound:", error);
            this.playBeepSound(); // Fallback on error
          }
        }

        /**
         * Generates and plays a simple beep sound using Web Audio API.
         */
        playBeepSound() {
          try {
            if (!this.audioContext) {
              this.audioContext = new (window.AudioContext ||
                window.webkitAudioContext)();
            }
            if (this.audioContext.state === "suspended") {
              this.audioContext.resume();
            }

            const oscillator = this.audioContext.createOscillator();
            const gainNode = this.audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(this.audioContext.destination);

            oscillator.frequency.setValueAtTime(
              800, // Beep frequency
              this.audioContext.currentTime
            );
            gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime); // Set volume

            oscillator.start();
            oscillator.stop(this.audioContext.currentTime + 0.5); // Stop after 0.5 seconds
          } catch (error) {
            console.error("Audio playback not supported or failed:", error);
          }
        }

        /**
         * Handles the change in sound selection (shows/hides custom sound upload).
         */
        handleSoundChange() {
          this.selectedSound = this.soundSelect.value;

          // Show/hide custom sound input and upload button based on selection
          if (this.selectedSound === "custom") {
            this.customSound.style.display = "inline";
            this.uploadBtn.style.display = "inline";
          } else {
            this.customSound.style.display = "none";
            this.uploadBtn.style.display = "none";
          }
        }

        /**
         * Handles the selection and decoding of a custom audio file.
         */
        async handleCustomSound() {
          const file = this.customSound.files[0];
          if (!file) return;

          try {
            if (!this.audioContext) {
              this.audioContext = new (window.AudioContext ||
                window.webkitAudioContext)();
            }

            const arrayBuffer = await file.arrayBuffer();
            // Decode audio data into an AudioBuffer
            this.customAudioBuffer = await this.audioContext.decodeAudioData(
              arrayBuffer
            );

            console.log("Custom sound loaded successfully");
          } catch (error) {
            console.error("Error loading custom sound:", error);
            // Display a custom alert modal instead of browser's alert()
            this.showAlert(
              "Error Loading Sound",
              "Failed to load audio file. Please try a different one."
            );
          }
        }

        /**
         * Shows the custom alert modal.
         * @param {string} title The title for the alert.
         * @param {string} message The message content for the alert.
         */
        showAlert(
          title = "⏰ Time's Up!",
          message = "Your timer has finished!"
        ) {
          document.querySelector("#alertModal .alert-content h2").textContent =
            title;
          document.querySelector("#alertModal .alert-content p").textContent =
            message;
          this.alertModal.style.display = "flex";
          document.body.style.overflow = "hidden"; // Prevent body scrolling
        }

        /**
         * Closes the custom alert modal.
         */
        closeAlertModal() {
          this.alertModal.style.display = "none";
          document.body.style.overflow = "auto"; // Re-enable body scrolling
          this.timerDisplay.classList.remove("alert"); // Remove alert animation
        }

        /**
         * Tests the alarm sound and shows the alert modal.
         */
        testAlert() {
          this.playAlert();
          this.showAlert(
            "Test Alarm",
            "This is a test of your selected alarm sound!"
          );
        }
      }

      // Initialize the timer when the DOM is fully loaded
      document.addEventListener("DOMContentLoaded", () => {
        new Timer();
      });
    </script>
  </body>
</html>
